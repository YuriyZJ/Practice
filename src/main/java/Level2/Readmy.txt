/////Тема 1: Внутренние, вложенные, локальные, анонимные и утилитные классы
Task 1: Реализация вложенных классов
Создайте класс Car, который содержит вложенный статический класс Engine. У Engine должен быть метод start(), который выводит сообщение "Engine started".
В Car добавьте метод startCar(), который вызывает Engine.start().
Дополнительное задание:
Добавьте нестатический вложенный класс Transmission, который может переключать передачи (метод changeGear(int gear)).

Task 2: Локальный класс в методе
Создайте класс TextProcessor, который содержит метод processText(String text).
Внутри метода создайте локальный класс WordCounter, который умеет считать количество слов в переданной строке.
Метод processText() должен создавать экземпляр WordCounter и выводить в консоль количество слов в строке.

Задача 3: Анонимные классы в обработке событий
Создайте интерфейс ButtonClickListener с методом onClick().
В классе Button создайте метод setClickListener(ButtonClickListener listener), который принимает объект интерфейса и вызывает onClick().
В main() создайте объект Button и передайте в setClickListener() анонимный класс, который выводит "Button clicked" при нажатии.

Задача 4: Утилитный класс
Создайте утилитный класс MathUtils с private конструктором и статическими методами:
factorial(int n) — вычисляет факториал числа
isPrime(int n) — проверяет, является ли число простым
Напишите код, демонстрирующий использование методов.

/////Тема 2: Массивы и матрицы
Уровень 1: Начальный (Базовые операции)
Задача 1.1: Сумма элементов массива
Дан массив целых чисел. Найти сумму всех элементов.

Задача 1.2: Поиск минимума/максимума
Найти минимальный и максимальный элемент в массиве.

Уровень 2: Средний (Алгоритмы и преобразования)
Задача 2.1: Переворот массива
Развернуть массив в обратном порядке **без использования** дополнительного массива.

Задача 2.2: Сортировка "пузырьком"
Реализовать сортировку массива методом пузырька.

Уровень 3: Продвинутый (Матрицы и многомерные массивы)
Задача 3.1: Транспонирование матрицы
Написать метод, который транспонирует матрицу (меняет строки на столбцы).

Задача 3.2: Поиск в матрице
Дана матрица и число `X`. Проверить, есть ли `X` в матрице, и вернуть его координаты `[i][j]` или `[-1, -1]`, если элемента нет.

Уровень 4: Эксперт (Комбинированные задачи)
Задача 4.1: "Спиральный обход" матрицы
Вывести элементы матрицы по спирали (начиная с верхнего левого угла).

Задача 4.2: Поворот матрицы на 90°
Повернуть квадратную матрицу на 90 градусов по часовой стрелке **без использования** дополнительной матрицы.

/////Тема 3: Коллекции (Collections)
Лёгкий уровень
Задача 1. Уникальные слова в тексте
Напишите метод, который принимает List<String>, содержащий текст, и возвращает Set<String> со всеми уникальными словами (без учета регистра).
Задача 2. Очередь задач
Реализуйте класс TaskQueue, использующий Queue<String> для хранения задач. Добавьте методы addTask(String task), getNextTask(), isEmpty().

Средний уровень
Задача 1. Частота слов в тексте
Напишите метод, который принимает List<String>, подсчитывает частоту встречаемости слов и возвращает Map<String, Integer>.
Задача 2. LRU-кеш
Реализуйте LRUCache<K, V> с использованием LinkedHashMap. Размер кеша должен задаваться в конструкторе.

Сложный уровень
Задача 1. Сортировка списка объектов
Создайте класс Person (поля: name, age). Напишите код для сортировки List<Person> по age, а при равном возрасте — по name.
Задача 2. Обратный индекс документов
Даны документы (Map<Integer, String>), где ключ — ID, значение — текст. Реализуйте индекс (Map<String, Set<Integer>>), связывающий слова с ID документов.

Задача 4: HashMap для хранения студентов
Создайте HashMap<Integer, String>, где ключ — ID студента, а значение — его имя.
Добавьте в HashMap 5 студентов.
Реализуйте метод findStudentById(int id), который возвращает имя студента по ID.
Реализуйте метод removeStudent(int id), который удаляет студента.

Задача 5: Очередь на основе PriorityQueue
Создайте класс Task, содержащий String description и int priority.
Реализуйте Comparable<Task>, чтобы задачи с более высоким priority выполнялись раньше.
Используйте PriorityQueue<Task> для хранения и обработки задач.

Задача 6: Уникальные пользователи (Set)
Создайте класс User с id и name.
Добавьте несколько пользователей в HashSet<User>.
Дополнительное задание:
Реализуйте equals() и hashCode() так, чтобы пользователи с одинаковым id не дублировались.

Тема 3: Дженерики
Лёгкий уровень
Задача 1. Обобщённый метод поиска максимального элемента
Реализуйте метод <T extends Comparable<T>> T findMax(List<T> list), который возвращает максимальный элемент из списка.
Задача 2. Класс Pair
Создайте класс Pair<T, U>, который хранит два объекта разных типов. Реализуйте методы getFirst(), getSecond().

Средний уровень
Задача 1. Обобщённая очередь
Реализуйте GenericQueue<T>, используя LinkedList<T>. Добавьте методы enqueue(), dequeue(), isEmpty().
Задача 2. Обобщённый метод фильтрации
Напишите метод <T> List<T> filter(List<T> list, Predicate<T> predicate), который принимает список и предикат, возвращая отфильтрованный список.

Сложный уровень
Задача 1. Обобщённый стек с максимальным элементом
Реализуйте GenericStack<T extends Comparable<T>>, который помимо стандартных push() и pop() предоставляет метод getMax(), возвращающий максимальный элемент.
Задача 2. Кэш с ограниченным размером
Реализуйте BoundedCache<K, V> с ограниченным количеством элементов, где старые элементы удаляются при добавлении новых.

Задача 5: Дженерик-класс “Коробка”
Создайте класс Box<T>, который хранит объект типа T. Реализуйте методы:
setItem(T item) — устанавливает объект
getItem() — возвращает объект
printType() — выводит в консоль тип хранимого объекта
Дополнительное задание:
Добавьте метод swap(Box<T> other), который меняет местами содержимое двух коробок.

Задача 6: Ограниченные параметры (bounded type parameters)
Создайте класс NumberBox<T extends Number>, который хранит числа (Integer, Double, Float и т. д.).
Добавьте метод sum(NumberBox<?> other), который складывает числа из двух объектов NumberBox.

Задача 7: Дженерики и интерфейсы
Создайте интерфейс Sortable<T>, который содержит метод compareTo(T o).
Реализуйте этот интерфейс в классе Person, у которого есть name и age.
Сортировка должна происходить по возрасту.
Создайте список ArrayList<Person>, добавьте в него несколько людей и отсортируйте его с помощью Collections.sort().

Дополнительное задание для всех тем
Разработайте мини-приложение “Менеджер задач”, которое использует дженерики, коллекции и вложенные классы.
Каждая задача (Task) должна храниться в List<Task>.
У каждой задачи есть приоритет (PriorityQueue<Task>).
Для управления задачами используйте внутренние и анонимные классы.
Реализуйте сортировку и фильтрацию.

///////Тема 4: Исключения
Уровень 1 (Базовый)
Задача 1. Деление на ноль (Обработка исключений)
Напишите программу, которая запрашивает у пользователя два числа и делит первое на второе.
Если пользователь вводит 0 как знаменатель, программа должна перехватить ArithmeticException и вывести "Ошибка: Деление на ноль запрещено!".
В любом случае программа должна выводить "Операция завершена" (даже при исключении).

Задача 2. Проверка ввода (Multiple catch blocks)
Напишите программу, которая принимает от пользователя число и вычисляет его квадрат.
Если пользователь вводит не число, программа должна перехватить InputMismatchException и вывести "Ошибка: Введите корректное число!".
Используйте Scanner, а код ввода поместите в блок try.

Уровень 2 (Средний)
Задача 3. Кастомное исключение “Неверный возраст”
Создайте класс InvalidAgeException, наследующий Exception.
В классе User создайте метод setAge(int age), который выбрасывает InvalidAgeException, если возраст < 0 или > 150.
В main() попробуйте создать User с недопустимым возрастом и обработайте исключение.

Задача 4. Чтение файла с обработкой исключений
Создайте программу, которая читает файл "data.txt".
Обработайте FileNotFoundException (если файл не найден).
Обработайте IOException (если произошла ошибка при чтении).
В блоке finally закройте BufferedReader.

Уровень 3 (Продвинутый)
Задача 5. Автоуправляемые ресурсы (try-with-resources)
Создайте класс FileProcessor, который читает файл и закрывает его автоматически с помощью try-with-resources.
Используйте BufferedReader.
Программа должна безопасно закрывать файл даже при ошибке.

Задача 6. Передача исключений вверх (rethrow exception)
Создайте метод processData(), который читает число из файла и вычисляет его корень.
Если число отрицательное, выбрасывайте IllegalArgumentException.
Исключение должно пробрасываться в main(), где оно обрабатывается.

Тема 5: Лямбда-выражения
Лёгкий уровень
Задача 1. Фильтрация списка чисел
Напишите код, который фильтрует List<Integer>, оставляя только чётные числа.
Задача 2. Конкатенация строк
Используя Function<String, String>, создайте функцию, добавляющую “!” к строке.

Средний уровень
Задача 1. Сортировка списка строк по длине
Используя Comparator и лямбда-выражение, отсортируйте List<String> по длине.
Задача 2. Конвертер списка в другую коллекцию
Напишите метод List<Integer> convert(List<String> list, Function<String, Integer> converter), который конвертирует строки в числа.

Сложный уровень
Задача 1. Группировка списка объектов
Дано List<Person>, сгруппируйте людей по возрасту, используя Collectors.groupingBy().
Задача 2. Лямбда-эквивалент цикла forEach
Реализуйте метод, аналогичный forEach(), принимающий List<T> и Consumer<T>.

Тема 6: Многопоточность
Уровень 1 (Базовый)
Задача 1. Поток с задержкой (Thread.sleep)
Создайте поток, который выводит "Привет, мир!" каждые 2 секунды.
Используйте Thread.sleep(2000).
Запустите поток и убедитесь, что программа не завершается сразу.

Задача 2. Запуск потоков (Runnable vs Thread)
Создайте два потока:
Первый поток (Thread) выводит "Я поток Thread" 5 раз.
Второй поток (Runnable) выводит "Я поток Runnable" 5 раз.
Запустите оба потока в main().

Уровень 2 (Средний)
Задача 3. Синхронизация (synchronized)
Создайте класс Counter, у которого есть метод increment(), увеличивающий счетчик.
Запустите 3 потока, которые увеличивают счетчик до 1000.
Без synchronized результат будет некорректным. Исправьте проблему.

Задача 4. Producer-Consumer (wait/notify)
Реализуйте шаблон “Производитель – Потребитель”:
Producer кладет числа в Queue<Integer>.
Consumer забирает числа.
Используйте wait() и notify() для управления очередью.

Уровень 3 (Продвинутый)
Задача 5. Callable и Future
Создайте Callable<Integer>, который вычисляет сумму чисел от 1 до 100.
Запустите его через ExecutorService и получите результат через Future<Integer>.

Задача 6. Deadlock (Взаимная блокировка)
Создайте два объекта (lock1 и lock2).
Поток Thread1 захватывает lock1, затем lock2.
Поток Thread2 захватывает lock2, затем lock1.
Запустите оба потока и вызовите Deadlock.
Исправьте проблему с помощью tryLock() из ReentrantLock.

Тема 7: Сериализация и десериализация
Лёгкий уровень
Задача 1. Сохранение объекта в файл
Создайте класс Person (с полями name и age), реализуйте Serializable, сохраните объект в файл и загрузите обратно.
Задача 2. Сериализация списка объектов
Реализуйте метод, который сериализует List<Person> в файл, а затем загружает его.

Средний уровень
Задача 1. Временные поля
Добавьте в Person поле transient String password и проверьте, что после десериализации оно null.
Задача 2. Кастомная сериализация
Реализуйте writeObject() и readObject(), чтобы поле password сохранялось шифрованным.

Сложный уровень
Задача 1. Сериализация в JSON
Используя Jackson или Gson, сериализуйте и десериализуйте Person в JSON.
Задача 2. Сеть и сериализация
Напишите клиент-серверное приложение, передающее сериализованный объект Person через Socket.

Тема 8. Юнит-тесты, тестирование с моками, исключения, поведение и валидации
Уровень 1 — Начальный (JUnit Basics)
Задача 1.1: Протестировать простую бизнес-логику
Класс:
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    public int subtract(int a, int b) {
        return a - b;
    }
}
Задача:
Создай юнит-тесты, проверяющие корректность работы методов add() и subtract():
- положительные числа;
- отрицательные;
- нули.
Задача 1.2: Проверка исключения
Класс:
public class DivisionService {
    public int divide(int a, int b) {
        if (b == 0) throw new IllegalArgumentException("Divider can't be zero");
        return a / b;
    }
}
Задача:
Напиши тест, который проверяет, что при делении на 0 выбрасывается IllegalArgumentException, а при корректном вводе возвращается правильный результат.

Задача 1.3: Проверка метода isEven()
Класс:
public class NumberUtils {
    public boolean isEven(int number) {
        return number % 2 == 0;
    }
}
Задача:
Напиши параметризованный тест, который проверяет:
	1.	Что метод возвращает true для чётных чисел (например: 2, 4, 10, 100).
	2.	Что метод возвращает false для нечётных чисел (например: 1, 3, 5, 101).

Уровень 2 — Средний (JUnit + Mockito Basics)
Задача 2.1: Тест с заглушкой (Mockito)
Классы:
public interface UserRepository {
    User findById(Long id);
}

public class UserService {
    private final UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public String getUserEmail(Long id) {
        User user = repository.findById(id);
        return user != null ? user.getEmail() : null;
    }
}
Задача:
Создай мок UserRepository с помощью Mockito. Напиши тест, который:
- возвращает пользователя с email “test@example.com”;
- проверяет, что email действительно вернулся;
- проверяет, что метод findById() вызван с нужным id.
Задача 2.2: Проверка взаимодействия
Класс:
public class NotificationService {
    public void send(String message) {
        System.out.println("Sending: " + message);
    }
}

public class AlertManager {
    private final NotificationService notificationService;

    public AlertManager(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void sendAlert(String level) {
        if ("HIGH".equals(level)) {
            notificationService.send("High level alert!");
        }
    }
}
Задача:
С помощью Mockito проверь, что при вызове sendAlert("HIGH") вызывается метод send(...) с нужным сообщением. Убедись, что при уровне "LOW" метод не вызывается.

Уровень 3 — Продвинутый (Mockito Stubbing & Verification)
Задача 3.1: Поведение при сложной логике
Класс:
public class OrderService {
    private final PaymentGateway gateway;

    public OrderService(PaymentGateway gateway) {
        this.gateway = gateway;
    }

    public boolean placeOrder(Order order) {
        if (order == null || order.getAmount() <= 0) return false;
        return gateway.charge(order.getAmount());
    }
}
Задача:
Протестируй метод placeOrder():
- Мокни PaymentGateway, чтобы он возвращал true;
- Проверь, что метод charge() вызывается только если сумма заказа > 0;
- Убедись, что заказ с нулевой или отрицательной суммой не приводит к вызову charge().
Задача 3.2: Множественные вызовы и аргументы
Класс:
public class EmailSender {
    public void sendEmail(String to, String subject, String body) {}
}

public class EmailService {
    private final EmailSender sender;

    public EmailService(EmailSender sender) {
        this.sender = sender;
    }

    public void sendWelcomeEmails(List<String> emails) {
        for (String email : emails) {
            sender.sendEmail(email, "Welcome", "Hello, new user!");
        }
    }
}
Задача:
- Создай мок EmailSender;
- Проверь, что sendEmail() вызывается ровно столько раз, сколько email-ов;
- Проверь, что каждый вызов был с нужными аргументами;
- Добавь тест, где список email-ов пустой — и убедись, что sendEmail() не вызывается вообще.

Тема 9. Юнит-тесты, тестирование с моками, исключения, поведение и валидации
Уровень 1 — Базовый (введение в Spring Core)
1. Создай простое Java-приложение с двумя бинами: Car и Engine. Настрой их с помощью аннотации @Component и внедри Engine в Car с помощью @Autowired.
2. Создай конфигурационный класс с @Configuration и добавь туда вручную бины с помощью @Bean.
3. Настрой ApplicationContext и получи бин Car, вызови метод start(), который вызывает метод ignite() у двигателя.
4. Добавь интерфейс Vehicle, реализуемый Car и Bike. Используй @Qualifier, чтобы внедрять нужный бин.
5. Попробуй внедрить зависимости через конструктор и через сеттер, сравни подходы.

Уровень 2 — Средний (Spring Boot + зависимости)
Цель: создать простое Spring Boot-приложение, познакомиться с автоконфигурацией и профилями.
1. Создай Spring Boot-приложение с зависимостью spring-boot-starter. Запусти его и проверь, как работает встроенный main().
2. Сделай REST-контроллер с одним эндпоинтом /hello, который возвращает строку.
3. Создай сервис GreetingService, внедри его в контроллер через конструктор.
4. Добавь зависимости из application.properties (например, greeting.message=Hello from config) и используй @Value для внедрения.
5. Настрой два профиля (например, dev и prod) и создай разные сообщения для каждого через application-dev.properties и application-prod.properties.

Уровень 3 — Продвинутый (слой сервисов, репозиториев, интеграция с базой)
Цель: познакомиться со слоями приложения, базой данных, CRUD.
1. Создай сущность User с полями id, name, email.
2. Настрой базу данных H2, сделай подключение в application.properties.
3. Создай интерфейс UserRepository, используй JpaRepository.
4. Создай UserService с методами getAll(), save(User user), delete(Long id), и подключи его к контроллеру.
5. Сделай REST-API: GET /users, POST /users, DELETE /users/{id}.