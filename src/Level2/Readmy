Тема 1: Внутренние, вложенные, локальные, анонимные и утилитные классы
Task 1: Реализация вложенных классов
Создайте класс Car, который содержит вложенный статический класс Engine. У Engine должен быть метод start(), который выводит сообщение "Engine started".
В Car добавьте метод startCar(), который вызывает Engine.start().
Дополнительное задание:
Добавьте нестатический вложенный класс Transmission, который может переключать передачи (метод changeGear(int gear)).

Task 2: Локальный класс в методе
Создайте класс TextProcessor, который содержит метод processText(String text).
Внутри метода создайте локальный класс WordCounter, который умеет считать количество слов в переданной строке.
Метод processText() должен создавать экземпляр WordCounter и выводить в консоль количество слов в строке.

Задача 3: Анонимные классы в обработке событий
Создайте интерфейс ButtonClickListener с методом onClick().
В классе Button создайте метод setClickListener(ButtonClickListener listener), который принимает объект интерфейса и вызывает onClick().
В main() создайте объект Button и передайте в setClickListener() анонимный класс, который выводит "Button clicked" при нажатии.

Задача 4: Утилитный класс
Создайте утилитный класс MathUtils с private конструктором и статическими методами:
factorial(int n) — вычисляет факториал числа
isPrime(int n) — проверяет, является ли число простым
Напишите код, демонстрирующий использование методов.

Тема 2: Коллекции (Collections)
Задача 8: HashMap для хранения студентов
Создайте HashMap<Integer, String>, где ключ — ID студента, а значение — его имя.
Добавьте в HashMap 5 студентов.
Реализуйте метод findStudentById(int id), который возвращает имя студента по ID.
Реализуйте метод removeStudent(int id), который удаляет студента.

Задача 9: Очередь на основе PriorityQueue
Создайте класс Task, содержащий String description и int priority.
Реализуйте Comparable<Task>, чтобы задачи с более высоким priority выполнялись раньше.
Используйте PriorityQueue<Task> для хранения и обработки задач.

Задача 10: Уникальные пользователи (Set)
Создайте класс User с id и name.
Добавьте несколько пользователей в HashSet<User>.
Дополнительное задание:
Реализуйте equals() и hashCode() так, чтобы пользователи с одинаковым id не дублировались.

Тема 2: Дженерики
Задача 5: Дженерик-класс “Коробка”
Создайте класс Box<T>, который хранит объект типа T. Реализуйте методы:
setItem(T item) — устанавливает объект
getItem() — возвращает объект
printType() — выводит в консоль тип хранимого объекта
Дополнительное задание:
Добавьте метод swap(Box<T> other), который меняет местами содержимое двух коробок.

Задача 6: Ограниченные параметры (bounded type parameters)
Создайте класс NumberBox<T extends Number>, который хранит числа (Integer, Double, Float и т. д.).
Добавьте метод sum(NumberBox<?> other), который складывает числа из двух объектов NumberBox.

Задача 7: Дженерики и интерфейсы
Создайте интерфейс Sortable<T>, который содержит метод compareTo(T o).
Реализуйте этот интерфейс в классе Person, у которого есть name и age.
Сортировка должна происходить по возрасту.
Создайте список ArrayList<Person>, добавьте в него несколько людей и отсортируйте его с помощью Collections.sort().

Дополнительное задание для всех тем
Разработайте мини-приложение “Менеджер задач”, которое использует дженерики, коллекции и вложенные классы.
Каждая задача (Task) должна храниться в List<Task>.
У каждой задачи есть приоритет (PriorityQueue<Task>).
Для управления задачами используйте внутренние и анонимные классы.
Реализуйте сортировку и фильтрацию.

Тема 4: Исключения
Уровень 1 (Базовый)
Задача 1. Деление на ноль (Обработка исключений)
Напишите программу, которая запрашивает у пользователя два числа и делит первое на второе.
Если пользователь вводит 0 как знаменатель, программа должна перехватить ArithmeticException и вывести "Ошибка: Деление на ноль запрещено!".
В любом случае программа должна выводить "Операция завершена" (даже при исключении).

Задача 2. Проверка ввода (Multiple catch blocks)
Напишите программу, которая принимает от пользователя число и вычисляет его квадрат.
Если пользователь вводит не число, программа должна перехватить InputMismatchException и вывести "Ошибка: Введите корректное число!".
Используйте Scanner, а код ввода поместите в блок try.

Уровень 2 (Средний)
Задача 3. Кастомное исключение “Неверный возраст”
Создайте класс InvalidAgeException, наследующий Exception.
В классе User создайте метод setAge(int age), который выбрасывает InvalidAgeException, если возраст < 0 или > 150.
В main() попробуйте создать User с недопустимым возрастом и обработайте исключение.

Задача 4. Чтение файла с обработкой исключений
Создайте программу, которая читает файл "data.txt".
Обработайте FileNotFoundException (если файл не найден).
Обработайте IOException (если произошла ошибка при чтении).
В блоке finally закройте BufferedReader.

Уровень 3 (Продвинутый)
Задача 5. Автоуправляемые ресурсы (try-with-resources)
Создайте класс FileProcessor, который читает файл и закрывает его автоматически с помощью try-with-resources.
Используйте BufferedReader.
Программа должна безопасно закрывать файл даже при ошибке.

Задача 6. Передача исключений вверх (rethrow exception)
Создайте метод processData(), который читает число из файла и вычисляет его корень.
Если число отрицательное, выбрасывайте IllegalArgumentException.
Исключение должно пробрасываться в main(), где оно обрабатывается.

Тема 2: Многопоточность
Уровень 1 (Базовый)
Задача 1. Поток с задержкой (Thread.sleep)
Создайте поток, который выводит "Привет, мир!" каждые 2 секунды.
Используйте Thread.sleep(2000).
Запустите поток и убедитесь, что программа не завершается сразу.

Задача 2. Запуск потоков (Runnable vs Thread)
Создайте два потока:
Первый поток (Thread) выводит "Я поток Thread" 5 раз.
Второй поток (Runnable) выводит "Я поток Runnable" 5 раз.
Запустите оба потока в main().

Уровень 2 (Средний)
Задача 3. Синхронизация (synchronized)
Создайте класс Counter, у которого есть метод increment(), увеличивающий счетчик.
Запустите 3 потока, которые увеличивают счетчик до 1000.
Без synchronized результат будет некорректным. Исправьте проблему.

Задача 4. Producer-Consumer (wait/notify)
Реализуйте шаблон “Производитель – Потребитель”:
Producer кладет числа в Queue<Integer>.
Consumer забирает числа.
Используйте wait() и notify() для управления очередью.

Уровень 3 (Продвинутый)
Задача 5. Callable и Future
Создайте Callable<Integer>, который вычисляет сумму чисел от 1 до 100.
Запустите его через ExecutorService и получите результат через Future<Integer>.

Задача 6. Deadlock (Взаимная блокировка)
Создайте два объекта (lock1 и lock2).
Поток Thread1 захватывает lock1, затем lock2.
Поток Thread2 захватывает lock2, затем lock1.
Запустите оба потока и вызовите Deadlock.
Исправьте проблему с помощью tryLock() из ReentrantLock.