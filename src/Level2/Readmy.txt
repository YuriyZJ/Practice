/////Тема 1: Внутренние, вложенные, локальные, анонимные и утилитные классы
Task 1: Реализация вложенных классов
Создайте класс Car, который содержит вложенный статический класс Engine. У Engine должен быть метод start(), который выводит сообщение "Engine started".
В Car добавьте метод startCar(), который вызывает Engine.start().
Дополнительное задание:
Добавьте нестатический вложенный класс Transmission, который может переключать передачи (метод changeGear(int gear)).

Task 2: Локальный класс в методе
Создайте класс TextProcessor, который содержит метод processText(String text).
Внутри метода создайте локальный класс WordCounter, который умеет считать количество слов в переданной строке.
Метод processText() должен создавать экземпляр WordCounter и выводить в консоль количество слов в строке.

Задача 3: Анонимные классы в обработке событий
Создайте интерфейс ButtonClickListener с методом onClick().
В классе Button создайте метод setClickListener(ButtonClickListener listener), который принимает объект интерфейса и вызывает onClick().
В main() создайте объект Button и передайте в setClickListener() анонимный класс, который выводит "Button clicked" при нажатии.

Задача 4: Утилитный класс
Создайте утилитный класс MathUtils с private конструктором и статическими методами:
factorial(int n) — вычисляет факториал числа
isPrime(int n) — проверяет, является ли число простым
Напишите код, демонстрирующий использование методов.

/////Тема 2: Массивы и матрицы
Уровень 1: Начальный (Базовые операции)
Задача 1.1: Сумма элементов массива
Дан массив целых чисел. Найти сумму всех элементов.

Задача 1.2: Поиск минимума/максимума
Найти минимальный и максимальный элемент в массиве.

Уровень 2: Средний (Алгоритмы и преобразования)
Задача 2.1: Переворот массива
Развернуть массив в обратном порядке **без использования** дополнительного массива.

Задача 2.2: Сортировка "пузырьком"
Реализовать сортировку массива методом пузырька.

Уровень 3: Продвинутый (Матрицы и многомерные массивы)
Задача 3.1: Транспонирование матрицы
Написать метод, который транспонирует матрицу (меняет строки на столбцы).

Задача 3.2: Поиск в матрице
Дана матрица и число `X`. Проверить, есть ли `X` в матрице, и вернуть его координаты `[i][j]` или `[-1, -1]`, если элемента нет.

Уровень 4: Эксперт (Комбинированные задачи)
Задача 4.1: "Спиральный обход" матрицы
Вывести элементы матрицы по спирали (начиная с верхнего левого угла).

Задача 4.2: Поворот матрицы на 90°
Повернуть квадратную матрицу на 90 градусов по часовой стрелке **без использования** дополнительной матрицы.

/////Тема 3: Коллекции (Collections)
Лёгкий уровень
Задача 1. Уникальные слова в тексте
Напишите метод, который принимает List<String>, содержащий текст, и возвращает Set<String> со всеми уникальными словами (без учета регистра).
Задача 2. Очередь задач
Реализуйте класс TaskQueue, использующий Queue<String> для хранения задач. Добавьте методы addTask(String task), getNextTask(), isEmpty().

Средний уровень
Задача 1. Частота слов в тексте
Напишите метод, который принимает List<String>, подсчитывает частоту встречаемости слов и возвращает Map<String, Integer>.
Задача 2. LRU-кеш
Реализуйте LRUCache<K, V> с использованием LinkedHashMap. Размер кеша должен задаваться в конструкторе.

Сложный уровень
Задача 1. Сортировка списка объектов
Создайте класс Person (поля: name, age). Напишите код для сортировки List<Person> по age, а при равном возрасте — по name.
Задача 2. Обратный индекс документов
Даны документы (Map<Integer, String>), где ключ — ID, значение — текст. Реализуйте индекс (Map<String, Set<Integer>>), связывающий слова с ID документов.

Задача 4: HashMap для хранения студентов
Создайте HashMap<Integer, String>, где ключ — ID студента, а значение — его имя.
Добавьте в HashMap 5 студентов.
Реализуйте метод findStudentById(int id), который возвращает имя студента по ID.
Реализуйте метод removeStudent(int id), который удаляет студента.

Задача 5: Очередь на основе PriorityQueue
Создайте класс Task, содержащий String description и int priority.
Реализуйте Comparable<Task>, чтобы задачи с более высоким priority выполнялись раньше.
Используйте PriorityQueue<Task> для хранения и обработки задач.

Задача 6: Уникальные пользователи (Set)
Создайте класс User с id и name.
Добавьте несколько пользователей в HashSet<User>.
Дополнительное задание:
Реализуйте equals() и hashCode() так, чтобы пользователи с одинаковым id не дублировались.

Тема 3: Дженерики
Лёгкий уровень
Задача 1. Обобщённый метод поиска максимального элемента
Реализуйте метод <T extends Comparable<T>> T findMax(List<T> list), который возвращает максимальный элемент из списка.
Задача 2. Класс Pair
Создайте класс Pair<T, U>, который хранит два объекта разных типов. Реализуйте методы getFirst(), getSecond().

Средний уровень
Задача 1. Обобщённая очередь
Реализуйте GenericQueue<T>, используя LinkedList<T>. Добавьте методы enqueue(), dequeue(), isEmpty().
Задача 2. Обобщённый метод фильтрации
Напишите метод <T> List<T> filter(List<T> list, Predicate<T> predicate), который принимает список и предикат, возвращая отфильтрованный список.

Сложный уровень
Задача 1. Обобщённый стек с максимальным элементом
Реализуйте GenericStack<T extends Comparable<T>>, который помимо стандартных push() и pop() предоставляет метод getMax(), возвращающий максимальный элемент.
Задача 2. Кэш с ограниченным размером
Реализуйте BoundedCache<K, V> с ограниченным количеством элементов, где старые элементы удаляются при добавлении новых.

Задача 5: Дженерик-класс “Коробка”
Создайте класс Box<T>, который хранит объект типа T. Реализуйте методы:
setItem(T item) — устанавливает объект
getItem() — возвращает объект
printType() — выводит в консоль тип хранимого объекта
Дополнительное задание:
Добавьте метод swap(Box<T> other), который меняет местами содержимое двух коробок.

Задача 6: Ограниченные параметры (bounded type parameters)
Создайте класс NumberBox<T extends Number>, который хранит числа (Integer, Double, Float и т. д.).
Добавьте метод sum(NumberBox<?> other), который складывает числа из двух объектов NumberBox.

Задача 7: Дженерики и интерфейсы
Создайте интерфейс Sortable<T>, который содержит метод compareTo(T o).
Реализуйте этот интерфейс в классе Person, у которого есть name и age.
Сортировка должна происходить по возрасту.
Создайте список ArrayList<Person>, добавьте в него несколько людей и отсортируйте его с помощью Collections.sort().

Дополнительное задание для всех тем
Разработайте мини-приложение “Менеджер задач”, которое использует дженерики, коллекции и вложенные классы.
Каждая задача (Task) должна храниться в List<Task>.
У каждой задачи есть приоритет (PriorityQueue<Task>).
Для управления задачами используйте внутренние и анонимные классы.
Реализуйте сортировку и фильтрацию.

///////Тема 4: Исключения
Уровень 1 (Базовый)
Задача 1. Деление на ноль (Обработка исключений)
Напишите программу, которая запрашивает у пользователя два числа и делит первое на второе.
Если пользователь вводит 0 как знаменатель, программа должна перехватить ArithmeticException и вывести "Ошибка: Деление на ноль запрещено!".
В любом случае программа должна выводить "Операция завершена" (даже при исключении).

Задача 2. Проверка ввода (Multiple catch blocks)
Напишите программу, которая принимает от пользователя число и вычисляет его квадрат.
Если пользователь вводит не число, программа должна перехватить InputMismatchException и вывести "Ошибка: Введите корректное число!".
Используйте Scanner, а код ввода поместите в блок try.

Уровень 2 (Средний)
Задача 3. Кастомное исключение “Неверный возраст”
Создайте класс InvalidAgeException, наследующий Exception.
В классе User создайте метод setAge(int age), который выбрасывает InvalidAgeException, если возраст < 0 или > 150.
В main() попробуйте создать User с недопустимым возрастом и обработайте исключение.

Задача 4. Чтение файла с обработкой исключений
Создайте программу, которая читает файл "data.txt".
Обработайте FileNotFoundException (если файл не найден).
Обработайте IOException (если произошла ошибка при чтении).
В блоке finally закройте BufferedReader.

Уровень 3 (Продвинутый)
Задача 5. Автоуправляемые ресурсы (try-with-resources)
Создайте класс FileProcessor, который читает файл и закрывает его автоматически с помощью try-with-resources.
Используйте BufferedReader.
Программа должна безопасно закрывать файл даже при ошибке.

Задача 6. Передача исключений вверх (rethrow exception)
Создайте метод processData(), который читает число из файла и вычисляет его корень.
Если число отрицательное, выбрасывайте IllegalArgumentException.
Исключение должно пробрасываться в main(), где оно обрабатывается.

Тема 5: Лямбда-выражения
Лёгкий уровень
Задача 1. Фильтрация списка чисел
Напишите код, который фильтрует List<Integer>, оставляя только чётные числа.
Задача 2. Конкатенация строк
Используя Function<String, String>, создайте функцию, добавляющую “!” к строке.

Средний уровень
Задача 1. Сортировка списка строк по длине
Используя Comparator и лямбда-выражение, отсортируйте List<String> по длине.
Задача 2. Конвертер списка в другую коллекцию
Напишите метод List<Integer> convert(List<String> list, Function<String, Integer> converter), который конвертирует строки в числа.

Сложный уровень
Задача 1. Группировка списка объектов
Дано List<Person>, сгруппируйте людей по возрасту, используя Collectors.groupingBy().
Задача 2. Лямбда-эквивалент цикла forEach
Реализуйте метод, аналогичный forEach(), принимающий List<T> и Consumer<T>.

Тема 6: Многопоточность
Уровень 1 (Базовый)
Задача 1. Поток с задержкой (Thread.sleep)
Создайте поток, который выводит "Привет, мир!" каждые 2 секунды.
Используйте Thread.sleep(2000).
Запустите поток и убедитесь, что программа не завершается сразу.

Задача 2. Запуск потоков (Runnable vs Thread)
Создайте два потока:
Первый поток (Thread) выводит "Я поток Thread" 5 раз.
Второй поток (Runnable) выводит "Я поток Runnable" 5 раз.
Запустите оба потока в main().

Уровень 2 (Средний)
Задача 3. Синхронизация (synchronized)
Создайте класс Counter, у которого есть метод increment(), увеличивающий счетчик.
Запустите 3 потока, которые увеличивают счетчик до 1000.
Без synchronized результат будет некорректным. Исправьте проблему.

Задача 4. Producer-Consumer (wait/notify)
Реализуйте шаблон “Производитель – Потребитель”:
Producer кладет числа в Queue<Integer>.
Consumer забирает числа.
Используйте wait() и notify() для управления очередью.

Уровень 3 (Продвинутый)
Задача 5. Callable и Future
Создайте Callable<Integer>, который вычисляет сумму чисел от 1 до 100.
Запустите его через ExecutorService и получите результат через Future<Integer>.

Задача 6. Deadlock (Взаимная блокировка)
Создайте два объекта (lock1 и lock2).
Поток Thread1 захватывает lock1, затем lock2.
Поток Thread2 захватывает lock2, затем lock1.
Запустите оба потока и вызовите Deadlock.
Исправьте проблему с помощью tryLock() из ReentrantLock.

Тема 7: Сериализация и десериализация
Лёгкий уровень
Задача 1. Сохранение объекта в файл
Создайте класс Person (с полями name и age), реализуйте Serializable, сохраните объект в файл и загрузите обратно.
Задача 2. Сериализация списка объектов
Реализуйте метод, который сериализует List<Person> в файл, а затем загружает его.

Средний уровень
Задача 1. Временные поля
Добавьте в Person поле transient String password и проверьте, что после десериализации оно null.
Задача 2. Кастомная сериализация
Реализуйте writeObject() и readObject(), чтобы поле password сохранялось шифрованным.

Сложный уровень
Задача 1. Сериализация в JSON
Используя Jackson или Gson, сериализуйте и десериализуйте Person в JSON.
Задача 2. Сеть и сериализация
Напишите клиент-серверное приложение, передающее сериализованный объект Person через Socket.